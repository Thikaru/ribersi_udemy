# 三層アーキテクチャの実装

- [READMEへ](../README.md)

## アプリケーションアーキテクチャとは？

アーキテクチャはソフトウェア開発では，構造・構成という意味

### アプリケーションアーキテクチャ
かなり曖昧の言葉．
開発するアプリケーション構造のこと

- 広い範囲では，ある目的で開発する要素全体の構成が論点

- 狭い範囲では，独立して動作する1要素の内部の構成が論点．
	- サーバサイドのコードをどんな構造にするか

### インテグレーションアーキテクチャ

システム間の連携をどのように実現するか．

### インフラアーキテクチャ

サーバやネットワークの構成をどうするか？

### 本レクチャは？
まとまって動作するコードの構成をどのように整理するかを学ぶ
特にサーバサイドの整理をする

- 他にも以下のキーワードがある
 - MVC,MVVM,MVP
 - トランザクションスクリプト，ドメインモデル
 - リポジトリ，アクティブレコード
 - 3層アーキテクチャ，レイヤードアーキテクチャ，クリーンアーキテクチャ

### 三層アーキテクチャ

Webサーバ，アプリケーション，DBの3つのから成り立つ3層構造のことを言うこともある
- Webサーバ：固定のHTML・CSS・JSなどを返し，プログラムによる処理が必要な場合は，アプリケーションに依頼する
- アプリケーション：プログラムでHTMLやJSONなどを生成して返す
- DB：

アプリケーションの内部を3層に分けて整理することもある．これも3層アーキテクチャともいう．
今回はこちらを勉強していく
- プレゼンテーション層（インターフェース層）：アプリケーションの利用者
- ビジネスロジック層（アプリケーション層）：
- データアクセス層：DBやファイルなどのデータの保存先とやりとりする


フロントエンドは，ブラウザなどユーザの手元で処理される．
サーバサイドは，サーバ上で処理される．
プレゼンテーション層は，今回は，ブラウザのJSと通信する場合．
今回のようにAPI層で連携する場合は，プレゼンテーション層はAPIを受け取る場所．
RailsでERB，LaravelでBlade，SpringでThymeleafを使ってサーバサイドでHTMLを生成する方式の場合は，プレゼンテーション層はフロントエンドにある．

### Table Data Gatewayパターン
データアクセス層の実装には，以下のような様々なパターンがある．
- Table Data Gateway
- Repository
- Active Record

ここでは，テーブルと1対1対応するクラスを作成し，対象のテーブルとのやりとりを記述する，Table Data Gatewayと呼ばれるパターンで実装する．
Javaでは，DAO（データアクセスオブジェクト）というパターンで呼ばれる．

## プレゼンテーション層
- Routerを使って処理ごとの処理をまとめる
  - game
  - turn　など

このアプリの利用者とやりとりすること
リクエストからパラメータを取り出したり，レスポンスを返すのみ

## サービスクラス

現在書いているプレゼンテーション層にある，リクエストから変数を取り出す処理と，レスポンスで返す処理以外をサービスクラス（ビジネスロジック）内に移行する．これにより，プレゼンテーション層とサービスクラスをしっかり分けた設計にする．

## リクエストやレスポンスの型を作成

リクエストやレスポンスの型を作成する．APIのレスポンスが変わる可能性があり，それを防ぐためにもしっかり型を決めるべきである．
DTO(Data Transfer Object)データの入れ物クラス

## 3層アーキテクチャとMVCの関係

MVCと3層アーキテクチャの各要素は1体1では対応しない．
プレゼンテーション層：ControllerとView
ビジネスロジックとデータアクセス層：をなんとなくModelという

今回実装した例は，下記のように考えれるかも？
Router ＝　Contorller
Response ＝　View
Service＋OutPut＋Gateway＋Record　＝Model

役割分担しているのがいいのであって，MVCを使うことが正しいわけではない．

## ビジネスロジック（主観入ってる）

---

ビジネスロジックは，システムのコアやシステムの目的の処理をするところと言われることが多い．

＜例＞ビジネスロジック層に書くべきコード

TurnServiceのregisterTurnメソッドを見てみると以下のようなコードを実装す流ことになる．

- データアクセス層を使って1つ前のターンを取得する
- 盤面に置けるかチェック
- 石を置く
- ひっくり返す
- データアクセス層を使ってターンを保存する

### これはビジネスロジック？？

同じ処理であってもアプリケーションの性質次第でビジネスロジックと言える場合と言えない場合がある．

- 日付の見た目を変換する処理
    - 2024-01-12を2024年1月12日
    - 見た目を整える処理は，プレゼンテーション層の役割であると判断されることが多い
    - しかし，日付時刻形式変換アプリケーションならばビジネスロジック層であるといえる
- リクエストの形式チェック
    - プレゼンテーション層でチェックすべきと考えられる
        - 利用者とのインタフェースでの約束事に関するチェック
        - 不正なデータはできるだけ早く検知するべき
- リクエスト形式より複雑なチェック
    - SNSでいいね自分につかないようにする
    - ビジネスロジック層
        - プレゼンテーション層は見た目などのUIに直接関わることだけ知っておくべき
        - UIがGUI，API，CLIによる違いによらず共通したチェックであるから
- DBとの整合性
    - ビジネスロジック
    - アプリケーションが従うべきルールのチェックであったり，ルールを適用する計算処理がビジネスロジックの中心

- 処理の流れを実現すること：「ユースケース」「アプリケーションビジネスルール」
- システム都合ではなくコアなルール：「ドメインロジック」「エンタープライズビジネスルール」

### ドメインロジックの例

- 盤面に置けるかチェック
- 挟まれた石をひっくり返す

システムなしで，現実世界で同じことをやろうとしたときにも，登場するルールは，ドメインロジックのわかりやすい例．

＜ビジネスロジックの実装方式＞

- トランザクションスクリプトパターン

＜概要＞

データの入れ物と処理を分離する

手続き型プログラミング

Serviceがドメインロジックとユースケースを担当

＜メリット＞

学習コスト低い

＜デメリット＞

同じロジックがService間に分散しやすく，変更に弱い

Serviceクラスが肥大化しやすい

- ドメインモデルパターン

＜概要＞

データの入れ物に処理も持たせる

オブジェクト指向プログラミング

Modelはドメインロジックを担当

Serviceはユースケース担当

＜メリット＞

同じロジックが分散しにくく，変更に強くなりやすい

Serviceクラスが肥大化しにくい

＜デメリット＞

学習コストが高い

<リポジトリパターン>

Serviceクラスがdataaccessのモデルに考えているから．Serviceが大きくなっている

これを解決するためにリポジトリパターンを利用する．

- ドメイン層のディレクトリ作成の方針

＜技術的な観点でディレクトリを分離＞

```markdown
domain/
  |--model
  |--repository
```

<ドメインモデルの観点でディレクトリを分離>

```markdown
domain/
  |--game
  |--turn
```

### 現時点でのアプリケーション構成

---

- レイヤードアーキテクチャ
    - インフラストラクチャ層：データベースアクセスや外部との連携など

- 層分け：3層・レイヤード
    - レーヤードでは，ビジネスロジック層がアプリケーション層とドメイン層に分離
- プレゼンテーション層：MVC
- ビジネスロジック層：トランザクションスクリプト・ドメインモデル
- データアクセス層：Table Data Gateway，Repository

ポイントは，「層分け」と「各層の実装方式」の観点があり，様々な組み合わせがあり得るということ．

### アーキテクチャの組み合わせ例

- 3層＋MVC＋トランザクションスクリプト＋Table Data Gateway
- レイヤード＋MVC＋ドメインモデル＋Repository

実際には組み合わせの制約や，内部的な組み合わせも考えられる

- レイヤードアーキテクチャは，ドメインモデルパターンを使う前提
- 今回のように，Repositoryの内部でTableDataGatewayを使うことも

アプリケーション設計に関する書籍を読んだりするときは，どの観点の話なのか注意してみると理解しやすくなることがある．